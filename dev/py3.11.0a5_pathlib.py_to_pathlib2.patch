--- a/../../python/cpython/Lib/pathlib.py
+++ b/src/pathlib2/__init__.py
@@ -1,3 +1,9 @@
+# Copyright (c) 2001-2022 Python Software Foundation; All Rights Reserved
+# Copyright (c) 2014-2022 Matthias C. M. Troffaes and contributors
+# Copyright (c) 2012-2014 Antoine Pitrou and contributors
+#
+# Distributed under the terms of the MIT License.
+
 import fnmatch
 import functools
 import io
@@ -46,10 +52,27 @@ def _is_wildcard_pattern(pat):
     return "*" in pat or "?" in pat or "[" in pat
 
 
+if sys.version_info >= (3, 10):
+    io_text_encoding = io.text_encoding
+else:
+    def io_text_encoding(encoding, stacklevel=2):
+        return encoding
+
+
+if sys.version_info >= (3, 8):
+    sys_audit = sys.audit
+else:
+    def sys_audit(*args):
+        return
+
+
 class _Flavour(object):
     """A flavour implements a particular (platform-specific) set of path
     semantics."""
 
+    sep: str
+    altsep: str
+
     def __init__(self):
         self.join = self.sep.join
 
@@ -274,6 +297,14 @@ def make_uri(self, path):
 _posix_flavour = _PosixFlavour()
 
 
+if sys.version_info >= (3, 10):
+    from os.path import realpath as os_path_realpath
+elif os.name == "posix":
+    from pathlib2._posixpath import realpath as os_path_realpath
+else:
+    from pathlib2._ntpath import realpath as os_path_realpath
+
+
 #
 # Globbing helpers
 #
@@ -934,7 +965,7 @@ def glob(self, pattern):
         """Iterate over this subtree and yield all existing files (of any
         kind, including directories) matching the given relative pattern.
         """
-        sys.audit("pathlib.Path.glob", self, pattern)
+        sys_audit("pathlib.Path.glob", self, pattern)
         if not pattern:
             raise ValueError("Unacceptable pattern: {!r}".format(pattern))
         drv, root, pattern_parts = self._flavour.parse_parts((pattern,))
@@ -949,7 +980,7 @@ def rglob(self, pattern):
         directories) matching the given relative pattern, anywhere in
         this subtree.
         """
-        sys.audit("pathlib.Path.rglob", self, pattern)
+        sys_audit("pathlib.Path.rglob", self, pattern)
         drv, root, pattern_parts = self._flavour.parse_parts((pattern,))
         if drv or root:
             raise NotImplementedError("Non-relative patterns are unsupported")
@@ -979,7 +1010,7 @@ def check_eloop(e):
                 raise RuntimeError("Symlink loop from %r" % e.filename)
 
         try:
-            s = os.path.realpath(self, strict=strict)
+            s = os_path_realpath(self, strict=strict)
         except OSError as e:
             check_eloop(e)
             raise
@@ -1029,7 +1060,7 @@ def open(self, mode='r', buffering=-1, encoding=None,
         the built-in open() function does.
         """
         if "b" not in mode:
-            encoding = io.text_encoding(encoding)
+            encoding = io_text_encoding(encoding)
         return io.open(self, mode, buffering, encoding, errors, newline)
 
     def read_bytes(self):
@@ -1043,7 +1074,7 @@ def read_text(self, encoding=None, errors=None):
         """
         Open the file in text mode, read it, and close the file.
         """
-        encoding = io.text_encoding(encoding)
+        encoding = io_text_encoding(encoding)
         with self.open(mode='r', encoding=encoding, errors=errors) as f:
             return f.read()
 
@@ -1063,7 +1094,7 @@ def write_text(self, data, encoding=None, errors=None, newline=None):
         if not isinstance(data, str):
             raise TypeError('data must be str, not %s' %
                             data.__class__.__name__)
-        encoding = io.text_encoding(encoding)
+        encoding = io_text_encoding(encoding)
         with self.open(mode='w', encoding=encoding, errors=errors, newline=newline) as f:
             return f.write(data)
 
@@ -1392,4 +1423,4 @@ class WindowsPath(Path, PureWindowsPath):
     __slots__ = ()
 
     def is_mount(self):
-        raise NotImplementedError("Path.is_mount() is unsupported on this system")
+        raise NotImplementedError("Path.is_mount() is unsupported on this system")
\ No newline at end of file
